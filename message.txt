```
from collections import deque


maze = [
    [11, 9, 5, 5, 5, 1, 5, 3, 9, 5, 1, 1, 5, 3, 9, 1, 1, 1, 3, 11], [12, 6, 9, 1, 3, 8, 1, 2, 12, 3, 12, 4, 3, 8, 2, 8, 4, 2, 10, 10], [9, 3, 12, 0, 2, 10, 10, 8, 3, 8, 5, 5, 6, 10, 8, 4, 1, 6, 10, 10], [10, 8, 1, 6, 8, 6, 8, 2, 12, 6, 9, 3, 9, 4, 4, 1, 4, 1, 2, 10], [8, 6, 10, 9, 2, 9, 6, 12, 1, 1, 6, 12, 4, 5, 1, 6, 9, 4, 4, 2], [8, 1, 2, 10, 10, 10, 15, 9, 6, 10, 15, 15, 15, 9, 4, 5, 2, 9, 5, 6], [10, 10, 8, 2, 12, 2, 15, 12, 5, 0, 5, 7, 15, 10, 9, 5, 4, 0, 5, 3], [10, 10, 10, 12, 5, 2, 15, 15, 15, 10, 15, 15, 15, 10, 12, 5, 3, 8, 1, 2], [8, 6, 12, 5, 1, 0, 3, 11, 15, 10, 15, 13, 5, 4, 5, 3, 14, 10, 8, 2], [10, 9, 5, 3, 8, 6, 10, 10, 15, 14, 15, 15, 15, 9, 3, 8, 1, 6, 8, 6], [14, 12, 3, 10, 8, 3, 12, 0, 7, 9, 1, 1, 5, 6, 10, 8, 2, 9, 4, 3], [9, 3, 10, 10, 14, 8, 3, 8, 1, 6, 8, 2, 9, 7, 10, 8, 6, 8, 1, 2], [8, 0, 6, 12, 5, 4, 6, 8, 6, 9, 6, 10, 10, 9, 4, 6, 9, 2, 8, 2], [10, 8, 1, 1, 1, 5, 5, 4, 3, 10, 9, 6, 10, 8, 1, 3, 10, 8, 2, 10], [12, 4, 6, 12, 4, 5, 5, 5, 6, 12, 4, 5, 4, 4, 4, 4, 4, 6, 12, 6]
]


width = len(maze[0])
height = len(maze)


converted_maze = []
for rows in range(2 * height + 1):
    row = []
    for cols in range(2 * width + 1):
        row.append(1)
    converted_maze.append(row)

print()

for line in maze:
    for info in line:
        bits = bin(info)[2:].zfill(4)
        print(bits, end=",")
    print()

x, y = 0, 0          # Â∑¶‰∏ä„Çª„É´„Å†„Åë
for y in range(height):
    cy = 2*y + 1
    for x in range(width):
        cx = 2*x + 1
        info = maze[y][x]
        bits = bin(info)[2:].zfill(4)

        converted_maze[cy][cx] = 0

        if bits[0] == "0":  # Â∑¶
            converted_maze[cy][cx-1] = 0
        if bits[1] == "0":  # ‰∏ã
            converted_maze[cy+1][cx] = 0
        if bits[2] == "0":  # Âè≥
            converted_maze[cy][cx+1] = 0
        if bits[3] == "0":  # ‰∏ä
            converted_maze[cy-1][cx] = 0

converted_maze[1][1] = 2
converted_maze[19][14] = 3

for c_line in converted_maze:
    print(f"{c_line},")

H = 2*height + 1
W = 2*width + 1

for x in range(W):
    converted_maze[0][x] = 1
    converted_maze[H-1][x] = 1
for y in range(H):
    converted_maze[y][0] = 1
    converted_maze[y][W-1] = 1


def draw_ascii_maze(converted_maze):
    WALL = "‚ñà‚ñà"
    START = "\x1b[42m  \x1b[0m"
    GOAL = "\x1b[41m  \x1b[0m"
    PATH = "  "
    WALK_PATH = "üë£"

    for row in converted_maze:
        line = ""
        for cell in row:
            if cell == 1:
                line += WALL
            elif cell == 0:
                line += PATH
            elif cell == 2:
                line += START
            elif cell == 3:
                line += GOAL
            elif cell == 4:
                line += WALK_PATH
        print(line)


draw_ascii_maze(converted_maze)


height = len(converted_maze)
width = len(converted_maze[0])

for y in range(height):
    for x in range(width):
        if converted_maze[y][x] == 2:
            start = (x, y)
        elif converted_maze[y][x] == 3:
            goal = (x, y)

print("Goal:", goal)

queue = deque()
queue.append(start)
visited = set()
visited.add(start)

counter = 0
prev = {}
prev[start] = None
while queue:
    x, y = queue.popleft()
    if (x, y) == goal:
        print(counter, "now:", x, y, "Here is the goal!!")
        break
    # else:
    #     print(counter, "now:", x, y)

    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        nx = x + dx
        ny = y + dy
        if 0 <= nx < width and 0 <= ny < height:
            if converted_maze[ny][nx] != 1 and (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append((nx, ny))
                prev[(nx, ny)] = (x, y)
    counter += 1

path = []
cur = goal

while cur is not None:
    path.append(cur)
    cur = prev[cur]

path.reverse()
print(path)
print("shortest way", len(path))

WALK_PAHT = "üë£"
for (x, y) in path:
    if converted_maze[y][x] == 0:
        converted_maze[y][x] = 4

draw_ascii_maze(converted_maze)
```